/*! iCheck v1.0.2 by Damir Sultanov, http://git.io/arlzeA, MIT Licensed */
(function(f) {
	function A(a, b, d) {
		var c = a[0],
			g = /er/.test(d) ? _indeterminate : /bl/.test(d) ? n : k,
			e = d == _update ? {
				checked: c[k],
				disabled: c[n],
				indeterminate: "true" == a.attr(_indeterminate) || "false" == a.attr(_determinate)
			} : c[g];
		if (/^(ch|di|in)/.test(d) && !e) x(a, g);
		else if (/^(un|en|de)/.test(d) && e) q(a, g);
		else if (d == _update)
			for (var f in e) e[f] ? x(a, f, !0) : q(a, f, !0);
		else if (!b || "toggle" == d) {
			if (!b) a[_callback]("ifClicked");
			e ? c[_type] !== r && q(a, g) : x(a, g)
		}
	}

	function x(a, b, d) {
		var c = a[0],
			g = a.parent(),
			e = b == k,
			u = b == _indeterminate,
			v = b == n,
			s = u ? _determinate : e ? y : "enabled",
			F = l(a, s + t(c[_type])),
			B = l(a, b + t(c[_type]));
		if (!0 !== c[b]) {
			if (!d && b == k && c[_type] == r && c.name) {
				var w = a.closest("form"),
					p = 'input[name="' + c.name + '"]',
					p = w.length ? w.find(p) : f(p);
				p.each(function() {
					this !== c && f(this).data(m) && q(f(this), b)
				})
			}
			u ? (c[b] = !0, c[k] && q(a, k, "force")) : (d || (c[b] = !0), e && c[_indeterminate] && q(a, _indeterminate, !1));
			D(a, e, b, d)
		}
		c[n] && l(a, _cursor, !0) && g.find("." + C).css(_cursor, "default");
		g[_add](B || l(a, b) || "");
		g.attr("role") && !u && g.attr("aria-" + (v ? n : k), "true");
		g[_remove](F || l(a, s) || "")
	}

	function q(a, b, d) {
		var c = a[0],
			g = a.parent(),
			e = b == k,
			f = b == _indeterminate,
			m = b == n,
			s = f ? _determinate : e ? y : "enabled",
			q = l(a, s + t(c[_type])),
			r = l(a, b + t(c[_type]));
		if (!1 !== c[b]) {
			if (f || !d || "force" == d) c[b] = !1;
			D(a, e, s, d)
		}!c[n] && l(a, _cursor, !0) && g.find("." + C).css(_cursor, "pointer");
		g[_remove](r || l(a, b) || "");
		g.attr("role") && !f && g.attr("aria-" + (m ? n : k), "false");
		g[_add](q || l(a, s) || "")
	}

	function E(a, b) {
		if (a.data(m)) {
			a.parent().html(a.attr("style", a.data(m).s || ""));
			if (b) a[_callback](b);
			a.off(".i").unwrap();
			f(_label + '[for="' + a[0].id + '"]').add(a.closest(_label)).off(".i")
		}
	}

	function l(a, b, f) {
		if (a.data(m)) return a.data(m).o[b + (f ? "" : "Class")]
	}

	function t(a) {
		return a.charAt(0).toUpperCase() + a.slice(1)
	}

	function D(a, b, f, c) {
		if (!c) {
			if (b) a[_callback]("ifToggled");
			a[_callback]("ifChanged")[_callback]("if" + t(f))
		}
	}
	var m = "iCheck",
		C = m + "-helper",
		r = "radio",
		k = "checked",
		y = "un" + k,
		n = "disabled";
	_determinate = "determinate";
	_indeterminate = "in" + _determinate;
	_update = "update";
	_type = "type";
	_click = "click";
	_touch = "touchbegin.i touchend.i";
	_add = "addClass";
	_remove = "removeClass";
	_callback = "trigger";
	_label = "label";
	_cursor = "cursor";
	_mobile = /ipad|iphone|ipod|android|blackberry|windows phone|opera mini|silk/i.test(navigator.userAgent);
	f.fn[m] = function(a, b) {
		var d = 'input[type="checkbox"], input[type="' + r + '"]',
			c = f(),
			g = function(a) {
				a.each(function() {
					var a = f(this);
					c = a.is(d) ? c.add(a) : c.add(a.find(d))
				})
			};
		if (/^(check|uncheck|toggle|indeterminate|determinate|disable|enable|update|destroy)$/i.test(a)) return a = a.toLowerCase(), g(this), c.each(function() {
			var c =
				f(this);
			"destroy" == a ? E(c, "ifDestroyed") : A(c, !0, a);
			f.isFunction(b) && b()
		});
		if ("object" != typeof a && a) return this;
		var e = f.extend({
				checkedClass: k,
				disabledClass: n,
				indeterminateClass: _indeterminate,
				labelHover: !0
			}, a),
			l = e.handle,
			v = e.hoverClass || "hover",
			s = e.focusClass || "focus",
			t = e.activeClass || "active",
			B = !!e.labelHover,
			w = e.labelHoverClass || "hover",
			p = ("" + e.increaseArea).replace("%", "") | 0;
		if ("checkbox" == l || l == r) d = 'input[type="' + l + '"]'; - 50 > p && (p = -50);
		g(this);
		return c.each(function() {
			var a = f(this);
			E(a);
			var c = this,
				b = c.id,
				g = -p + "%",
				d = 100 + 2 * p + "%",
				d = {
					position: "absolute",
					top: g,
					left: g,
					display: "block",
					width: d,
					height: d,
					margin: 0,
					padding: 0,
					background: "#fff",
					border: 0,
					opacity: 0
				},
				g = _mobile ? {
					position: "absolute",
					visibility: "hidden"
				} : p ? d : {
					position: "absolute",
					opacity: 0
				},
				l = "checkbox" == c[_type] ? e.checkboxClass || "icheckbox" : e.radioClass || "i" + r,
				z = f(_label + '[for="' + b + '"]').add(a.closest(_label)),
				u = !!e.aria,
				y = m + "-" + Math.random().toString(36).substr(2, 6),
				h = '<div class="' + l + '" ' + (u ? 'role="' + c[_type] + '" ' : "");
			u && z.each(function() {
				h +=
					'aria-labelledby="';
				this.id ? h += this.id : (this.id = y, h += y);
				h += '"'
			});
			h = a.wrap(h + "/>")[_callback]("ifCreated").parent().append(e.insert);
			d = f('<ins class="' + C + '"/>').css(d).appendTo(h);
			a.data(m, {
				o: e,
				s: a.attr("style")
			}).css(g);
			e.inheritClass && h[_add](c.className || "");
			e.inheritID && b && h.attr("id", m + "-" + b);
			"static" == h.css("position") && h.css("position", "relative");
			A(a, !0, _update);
			if (z.length) z.on(_click + ".i mouseover.i mouseout.i " + _touch, function(b) {
				var d = b[_type],
					e = f(this);
				if (!c[n]) {
					if (d == _click) {
						if (f(b.target).is("a")) return;
						A(a, !1, !0)
					} else B && (/ut|nd/.test(d) ? (h[_remove](v), e[_remove](w)) : (h[_add](v), e[_add](w)));
					if (_mobile) b.stopPropagation();
					else return !1
				}
			});
			a.on(_click + ".i focus.i blur.i keyup.i keydown.i keypress.i", function(b) {
				var d = b[_type];
				b = b.keyCode;
				if (d == _click) return !1;
				if ("keydown" == d && 32 == b) return c[_type] == r && c[k] || (c[k] ? q(a, k) : x(a, k)), !1;
				if ("keyup" == d && c[_type] == r) !c[k] && x(a, k);
				else if (/us|ur/.test(d)) h["blur" == d ? _remove : _add](s)
			});
			d.on(_click + " mousedown mouseup mouseover mouseout " + _touch, function(b) {
				var d =
					b[_type],
					e = /wn|up/.test(d) ? t : v;
				if (!c[n]) {
					if (d == _click) A(a, !1, !0);
					else {
						if (/wn|er|in/.test(d)) h[_add](e);
						else h[_remove](e + " " + t);
						if (z.length && B && e == v) z[/ut|nd/.test(d) ? _remove : _add](w)
					}
					if (_mobile) b.stopPropagation();
					else return !1
				}
			})
		})
	}
})(window.jQuery || window.Zepto);
(function($) {

  // Cached vars
  var _iCheck = 'iChecks',
    _iCheckHelper = _iCheck + '-helper',
    _checkbox = 'checkbox',
    _radio = 'radio',
    _checked = 'checked',
    _unchecked = 'un' + _checked,
    _disabled = 'disabled',
    _determinate = 'determinate',
    _indeterminate = 'in' + _determinate,
    _update = 'update',
    _type = 'type',
    _click = 'click',
    _touch = 'touchbegin.i touchend.i',
    _add = 'addClass',
    _remove = 'removeClass',
    _callback = 'trigger',
    _label = 'label',
    _cursor = 'cursor',
    _mobile = /ipad|iphone|ipod|android|blackberry|windows phone|opera mini|silk/i.test(navigator.userAgent);

  // Plugin init
  $.fn[_iCheck] = function(options, fire) {

    // Walker
    var handle = 'input[type="' + _checkbox + '"], input[type="' + _radio + '"]',
      stack = $(),
      walker = function(object) {
        object.each(function() {
          var self = $(this);

          if (self.is(handle)) {
            stack = stack.add(self);
          } else {
            stack = stack.add(self.find(handle));
          }
        });
      };

    // Check if we should operate with some method
    if (/^(check|uncheck|toggle|indeterminate|determinate|disable|enable|update|destroy)$/i.test(options)) {

      // Normalize method's name
      options = options.toLowerCase();

      // Find checkboxes and radio buttons
      walker(this);

      return stack.each(function() {
        var self = $(this);

        if (options == 'destroy') {
          tidy(self, 'ifDestroyed');
        } else {
          operate(self, true, options);
        }

        // Fire method's callback
        if ($.isFunction(fire)) {
          fire();
        }
      });

    // Customization
    } else if (typeof options == 'object' || !options) {

      // Check if any options were passed
      var settings = $.extend({
          checkedClass: _checked,
          disabledClass: _disabled,
          indeterminateClass: _indeterminate,
          labelHover: true
        }, options),

        selector = settings.handle,
        hoverClass = settings.hoverClass || 'hover',
        focusClass = settings.focusClass || 'focus',
        activeClass = settings.activeClass || 'active',
        labelHover = !!settings.labelHover,
        labelHoverClass = settings.labelHoverClass || 'hover',

        // Setup clickable area
        area = ('' + settings.increaseArea).replace('%', '') | 0;

      // Selector limit
      if (selector == _checkbox || selector == _radio) {
        handle = 'input[type="' + selector + '"]';
      }

      // Clickable area limit
      if (area < -50) {
        area = -50;
      }

      // Walk around the selector
      walker(this);

      return stack.each(function() {
        var self = $(this);

        // If already customized
        tidy(self);

        var node = this,
          id = node.id,

          // Layer styles
          offset = -area + '%',
          size = 100 + (area * 2) + '%',
          layer = {
            position: 'absolute',
            top: offset,
            left: offset,
            display: 'block',
            width: size,
            height: size,
            margin: 0,
            padding: 0,
            background: '#fff',
            border: 0,
            opacity: 0
          },

          // Choose how to hide input
          hide = _mobile ? {
            position: 'absolute',
            visibility: 'hidden'
          } : area ? layer : {
            position: 'absolute',
            opacity: 0
          },

          // Get proper class
          className = node[_type] == _checkbox ? settings.checkboxClass || 'i' + _checkbox : settings.radioClass || 'i' + _radio,

          // Find assigned labels
          label = $(_label + '[for="' + id + '"]').add(self.closest(_label)),

          // Check ARIA option
          aria = !!settings.aria,

          // Set ARIA placeholder
          ariaID = _iCheck + '-' + Math.random().toString(36).substr(2,6),

          // Parent & helper
          parent = '<div class="' + className + '" ' + (aria ? 'role="' + node[_type] + '" ' : ''),
          helper;

        // Set ARIA "labelledby"
        if (aria) {
          label.each(function() {
            parent += 'aria-labelledby="';

            if (this.id) {
              parent += this.id;
            } else {
              this.id = ariaID;
              parent += ariaID;
            }

            parent += '"';
          });
        }

        // Wrap input
        parent = self.wrap(parent + '/>')[_callback]('ifCreated').parent().append(settings.insert);

        // Layer addition
        helper = $('<ins class="' + _iCheckHelper + '"/>').css(layer).appendTo(parent);

        // Finalize customization
        self.data(_iCheck, {o: settings, s: self.attr('style')}).css(hide);
        !!settings.inheritClass && parent[_add](node.className || '');
        !!settings.inheritID && id && parent.attr('id', _iCheck + '-' + id);
        parent.css('position') == 'static' && parent.css('position', 'relative');
        operate(self, true, _update);

        // Label events
        if (label.length) {
          label.on(_click + '.i mouseover.i mouseout.i ' + _touch, function(event) {
            var type = event[_type],
              item = $(this);

            // Do nothing if input is disabled
            if (!node[_disabled]) {

              // Click
              if (type == _click) {
                if ($(event.target).is('a')) {
                  return;
                }
                operate(self, false, true);

              // Hover state
              } else if (labelHover) {

                // mouseout|touchend
                if (/ut|nd/.test(type)) {
                  parent[_remove](hoverClass);
                  item[_remove](labelHoverClass);
                } else {
                  parent[_add](hoverClass);
                  item[_add](labelHoverClass);
                }
              }

              if (_mobile) {
                event.stopPropagation();
              } else {
                return false;
              }
            }
          });
        }

        // Input events
        self.on(_click + '.i focus.i blur.i keyup.i keydown.i keypress.i', function(event) {
          var type = event[_type],
            key = event.keyCode;

          // Click
          if (type == _click) {
            return false;

          // Keydown
          } else if (type == 'keydown' && key == 32) {
            if (!(node[_type] == _radio && node[_checked])) {
              if (node[_checked]) {
                off(self, _checked);
              } else {
                on(self, _checked);
              }
            }

            return false;

          // Keyup
          } else if (type == 'keyup' && node[_type] == _radio) {
            !node[_checked] && on(self, _checked);

          // Focus/blur
          } else if (/us|ur/.test(type)) {
            parent[type == 'blur' ? _remove : _add](focusClass);
          }
        });

        // Helper events
        helper.on(_click + ' mousedown mouseup mouseover mouseout ' + _touch, function(event) {
          var type = event[_type],

            // mousedown|mouseup
            toggle = /wn|up/.test(type) ? activeClass : hoverClass;

          // Do nothing if input is disabled
          if (!node[_disabled]) {

            // Click
            if (type == _click) {
              operate(self, false, true);

            // Active and hover states
            } else {

              // State is on
              if (/wn|er|in/.test(type)) {

                // mousedown|mouseover|touchbegin
                parent[_add](toggle);

              // State is off
              } else {
                parent[_remove](toggle + ' ' + activeClass);
              }

              // Label hover
              if (label.length && labelHover && toggle == hoverClass) {

                // mouseout|touchend
                label[/ut|nd/.test(type) ? _remove : _add](labelHoverClass);
              }
            }

            if (_mobile) {
              event.stopPropagation();
            } else {
              return false;
            }
          }
        });
      });
    } else {
      return this;
    }
  };

  // Do something with inputs
  function operate(input, direct, method) {
    var node = input[0],
      state = /er/.test(method) ? _indeterminate : /bl/.test(method) ? _disabled : _checked,
      active = method == _update ? {
        checked: node[_checked],
        disabled: node[_disabled],
        indeterminate: input.attr(_indeterminate) == 'true' || input.attr(_determinate) == 'false'
      } : node[state];

    // Check, disable or indeterminate
    if (/^(ch|di|in)/.test(method) && !active) {
      on(input, state);

    // Uncheck, enable or determinate
    } else if (/^(un|en|de)/.test(method) && active) {
      off(input, state);

    // Update
    } else if (method == _update) {

      // Handle states
      for (var each in active) {
        if (active[each]) {
          on(input, each, true);
        } else {
          off(input, each, true);
        }
      }

    } else if (!direct || method == 'toggle') {

      // Helper or label was clicked
      if (!direct) {
        input[_callback]('ifClicked');
      }

      // Toggle checked state
      if (active) {
        if (node[_type] !== _radio) {
          off(input, state);
        }
      } else {
        on(input, state);
      }
    }
  }

  // Add checked, disabled or indeterminate state
  function on(input, state, keep) {
    var node = input[0],
      parent = input.parent(),
      checked = state == _checked,
      indeterminate = state == _indeterminate,
      disabled = state == _disabled,
      callback = indeterminate ? _determinate : checked ? _unchecked : 'enabled',
      regular = option(input, callback + capitalize(node[_type])),
      specific = option(input, state + capitalize(node[_type]));

    // Prevent unnecessary actions
    if (node[state] !== true) {

      // Toggle assigned radio buttons
      if (!keep && state == _checked && node[_type] == _radio && node.name) {
        var form = input.closest('form'),
          inputs = 'input[name="' + node.name + '"]';

        inputs = form.length ? form.find(inputs) : $(inputs);

        inputs.each(function() {
          if (this !== node && $(this).data(_iCheck)) {
            off($(this), state);
          }
        });
      }

      // Indeterminate state
      if (indeterminate) {

        // Add indeterminate state
        node[state] = true;

        // Remove checked state
        if (node[_checked]) {
          off(input, _checked, 'force');
        }

      // Checked or disabled state
      } else {

        // Add checked or disabled state
        if (!keep) {
          node[state] = true;
        }

        // Remove indeterminate state
        if (checked && node[_indeterminate]) {
          off(input, _indeterminate, false);
        }
      }

      // Trigger callbacks
      callbacks(input, checked, state, keep);
    }

    // Add proper cursor
    if (node[_disabled] && !!option(input, _cursor, true)) {
      parent.find('.' + _iCheckHelper).css(_cursor, 'default');
    }

    // Add state class
    parent[_add](specific || option(input, state) || '');

    // Set ARIA attribute
    if (!!parent.attr('role') && !indeterminate) {
      parent.attr('aria-' + (disabled ? _disabled : _checked), 'true');
    }

    // Remove regular state class
    parent[_remove](regular || option(input, callback) || '');
  }

  // Remove checked, disabled or indeterminate state
  function off(input, state, keep) {
    var node = input[0],
      parent = input.parent(),
      checked = state == _checked,
      indeterminate = state == _indeterminate,
      disabled = state == _disabled,
      callback = indeterminate ? _determinate : checked ? _unchecked : 'enabled',
      regular = option(input, callback + capitalize(node[_type])),
      specific = option(input, state + capitalize(node[_type]));

    // Prevent unnecessary actions
    if (node[state] !== false) {

      // Toggle state
      if (indeterminate || !keep || keep == 'force') {
        node[state] = false;
      }

      // Trigger callbacks
      callbacks(input, checked, callback, keep);
    }

    // Add proper cursor
    if (!node[_disabled] && !!option(input, _cursor, true)) {
      parent.find('.' + _iCheckHelper).css(_cursor, 'pointer');
    }

    // Remove state class
    parent[_remove](specific || option(input, state) || '');

    // Set ARIA attribute
    if (!!parent.attr('role') && !indeterminate) {
      parent.attr('aria-' + (disabled ? _disabled : _checked), 'false');
    }

    // Add regular state class
    parent[_add](regular || option(input, callback) || '');
  }

  // Remove all traces
  function tidy(input, callback) {
    if (input.data(_iCheck)) {

      // Remove everything except input
      input.parent().html(input.attr('style', input.data(_iCheck).s || ''));

      // Callback
      if (callback) {
        input[_callback](callback);
      }

      // Unbind events
      input.off('.i').unwrap();
      $(_label + '[for="' + input[0].id + '"]').add(input.closest(_label)).off('.i');
    }
  }

  // Get some option
  function option(input, state, regular) {
    if (input.data(_iCheck)) {
      return input.data(_iCheck).o[state + (regular ? '' : 'Class')];
    }
  }

  // Capitalize some string
  function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  // Executable handlers
  function callbacks(input, checked, callback, keep) {
    if (!keep) {
      if (checked) {
        input[_callback]('ifToggled');
      }

      input[_callback]('ifChanged')[_callback]('if' + capitalize(callback));
    }
  }
})(window.jQuery || window.Zepto);
